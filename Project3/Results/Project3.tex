\documentclass[maincolor=black]{exercise}
\settitle[Projektteil 3]{Algorithmik}
\addstudent[625391]{Kaspar-David Buss}
\addstudent[573537]{Julian Hoffmann}
\setgroup{Gruppe 2 (Mittwochsgruppe)}
\setlength{\parskip}{0em}
\setlength{\parindent}{3ex}
\usepackage[utf8]{inputenc}
\usepackage[]{listings}
\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage{enumitem}
\usepackage{booktabs}
\usepackage{changepage}

\lstset{literate=%
	{√ñ}{{\"O}}1
	{√Ñ}{{\"A}}1
	{√ú}{{\"U}}1
	{√ü}{{\ss}}1
	{√º}{{\"u}}1
	{√§}{{\"a}}1
	{√∂}{{\"o}}1
	{~}{{\textasciitilde}}1
}

\newcommand{\anf}[1]{‚Äû#1‚Äú}
\newcommand{\non}[1]{\overline{#1}}

\begin{document}
\section*{Vorgehensweise}
Wir haben eine L√∂sung dieser Aufgabe in Java implementiert. Unsere Implementation besteht aus verschiedenen Teilen, welche die einzelnen Aufgaben erf√ºllen.\par
Das erste Modul f√ºhrt den Modified-3-SAT-Algorithmus f√ºr eine bestimmte Formel aus. Das zweite Modul f√ºhrt, beginnend bei einer bestimmten Anzahl von Variablen und einer Verteilung $[i]$, die Suche nach $n_{max}$ und $m_3^{[i]}(n)$ aus. Das dritte Modul berechnet die Werte von $\sigma_3^{[i]}(n_{max},m)$, wenn $m$ um h√∂chstens 10\% von $m_3^{[i]}(n_{max})$ abweicht. Diese werden wir in diesem Abschnitt etwas genauer behandeln.

\subsection{Solver}
Die Klasse \anf{\texttt{Solver}} in unserer Implementierung erh√§lt als Eingabe eine bestimmte 3-KNF-Formel $\varphi$ mit $m$ Klauseln sowie die Anzahl der Variablen $\{x_1,x_2,...,x_n\}$. Intern ist eine solche Formel $\varphi$ bei uns ein Array von \texttt{int}-Werten der Gr√∂√üe $m \times 3$. Jedes Unterarray ist eine Klausel und die einzelnen Werte stehen f√ºr Literale. Ein positiver Wert $v$ steht hierbei f√ºr das Literal $x_v$, wohingegen ein negativer Wert $-v$ f√ºr das Literal $\non{x_v}$ steht.\par
Der Aufbau dieser Klasse besteht aus drei Ebenen. Die unterste Ebene ist eine Methode, die Random-3-SAT ausf√ºhrt und als zus√§tzliche Eingabe $l$, die Anzahl an Iterationen erh√§lt. Diese startet, wie angegeben, mit einer zuf√§lligen Belegung von Variablen, die hierbei einfach ein \texttt{boolean}-Array der L√§nge $n$ ist. Der \texttt{return}-Wert dieser Methode ist eine erf√ºllende Belegung, falls eine solche gefunden wurde.\par
Die n√§chste Ebene ist eine Methode, welche Modifified-3-SAT ausf√ºhrt und als zus√§tzliche Eingabe $r$, die Anzahl an Restarts erh√§lt Wie angegeben, startet diese $r$-mal die Random-3-SAT-Methode mit $l = 3\cdot n$. Der \texttt{return}-Wert ist abermals eine erf√ºllende Belegung, falls eine solche gefunden wurde.\par
Schlie√ülich gibt es noch eine \anf{\texttt{solve}}-Methode, die keine weiteren Eingaben erh√§lt. Diese berechnet zuerst die ben√∂tigte Anzahl an Restarts, um eine Fehlerwahrscheinlichkeit von h√∂chstens $10^{-13}$ zu erreichen, in unserem Fall $r = 60 \cdot \left(\frac{4}{3}\right)^n$, und f√ºhrt Modified-3-SAT mit dieser Anzahl an Restarts aus. Falls eine erf√ºllende Belegung gefunden wurde, gibt diese \texttt{true} aus, sonst \texttt{false}.\par
Als Hilfsmethode ist noch eine Methode vorhanden, die √ºberpr√ºft, ob eine bestimmte Belegung die Formel erf√ºllt sowie eine Methode, die ein zuf√§lliges Literal in einer der nicht erf√ºllten Klauseln ausw√§hlt und dessen Wert in der Belegung √§ndert.

\subsection{MassSolver}
Die Klasse \anf{\texttt{MassSolver}} in unserer Implementierung besteht wiederum aus drei Teilen. Jede dieser erh√§lt als Eingabe immer die Zahl $i$ der Verteilung $[i]$, die angibt, wie die Klauseln generiert werden.\par
Die erste Ebene ist eine Methode, die als Eingabe ein bestimmtes Paar $(n,m)$ erh√§lt. Es wird 100-mal eine zuf√§llige Formel $\varphi$ mit $n$ Variablen und $m$ Klauseln generiert. Anschlie√üend wird versucht, mittels \texttt{Solver} eine erf√ºllende Belegung von $\varphi$ zu finden. Nach diesen 100 Versuchen wird die durchschnittliche Zeit $t$ pro Erf√ºllbarkeitssuche sowie der Anteil $a$ an erf√ºllten Formeln zu 100 ermittelt und ausgegeben.\par
Die zweite Ebene ist eine Methode, die wiederum ein Paar $(n,m)$ erh√§lt und an die erste Ebene weitergibt. Solange der oben genannte Anteil gr√∂√üer als $0.5$ ist, wird $m$ um 1 erh√∂ht und $(n,m)$ abermals an die erste Ebene weitergegeben. Sobald der Anteil f√ºr ein $(n,m_s)$ aber kleiner als $0.5$ ist, werden dieser Anteil $a_s$ sowie der vorige $a_{s-1}$ ausgew√§hlt und deren Abstand zu $0.5$ verglichen. Abh√§ngig davon, welcher Abstand kleiner ist, wird entweder $m_s$ oder $m_{s-1}$ ausgegeben. Dies ist $m_3^{[i]}(n)$. Zus√§tzlich wird die letzte Ausgabe von Ebene 1 ausgegeben. Dies basiert auf der Annahme, dass $\sigma_3^{[i]}(n,m)$ monoton fallend in $m$ ist, was Sinn macht, da mehr Anforderungen an die Belegung gegeben sind und daher ein Erfolg unwahrscheinlicher ist. Ferner konnten wir dies durch unsere Experimente best√§tigen.\par
Die dritte Ebene erh√§lt lediglich einen Startwert $n := n_{start}$ als Eingabe und baut ein Mapping $M: n \mapsto m_3^{[i]}(n)$ auf. $m$ startet hierbei bei 1. Das Tupel $(n,m)$ wird an Ebene 2 weitergegeben und die Ausgabe wird betrachtet, womit $m_3^{[i]}(n)$ bestimmt ist und in $M$ eingetragen wird. Solange die in Ebene 1 ermittelte durchschnittliche Zeit $t$ kleiner als 3 Sekunden ist, wird $m := m_3^{[i]}(n)$ gesetzt, $n$ um 1 inkrementiert und $(n,m)$ abermals an Ebene 2 weitergegeben. Sobald aber $t$ gr√∂√üer als 3 Sekunden ist, bricht die Schleife ab und es wird $M$ ausgegeben. Dies basiert auf der Annahme, dass $m_3^{[i]}(n)$ monoton steigend ist, was Sinn macht, da f√ºr gleich bleibendes $m$ ein gr√∂√üeres $n$ mehr Freiheiten bietet, um Belegungen zu erstellen. Ferner konnten wir dies durch unsere Experimente best√§tigen.\\
Diese Klasse enth√§lt weiterhin Hilfsmethoden zur Generierung von zuf√§lligen Formeln nach Verteilung $[1]$ oder $[2]$ sowie eine Methode, um aus einer Formel $\varphi$ triviale Klauseln, in denen $x \vee \non{x}$ f√ºr eine Variable $x$ vorkommt, sowie Duplikate von Klauseln zu entfernen. Letzteres ver√§ndert die Erf√ºllbarkeit der Formel nicht, macht aber die Erf√ºllbarkeitssuche deutlich schneller. Da die Klauseln \emph{unabh√§ngig} aus der Verteilung $[i]$ gew√§hlt werden, sind Duplikate n√§mlich noch nicht von vornherein ausgeschlossen.

F¸r Aufgabenteil b werden die Werte n_max, sowie die Anzahl der Klauseln m aus Aufgabenteil a benutzt. Bei Variante 1 werden also die Wahrscheinlichkeiten f¸r n_max = 29 und m im Intervall [122,148] berechnet. F¸r die zweite Variante werden die Wahrscheinlichkeiten von n_max = 27 und m im Intervall [111, 135] berechnet.

\section*{Ergebnisse}
\subsection{Aufgabe 3.3a)}
\begin{figure}[t]
	\includegraphics[width=\linewidth]{Diagram.png}
	\caption{Mapping von $n$ zu $m_3^{[i]}(n)$\label{fig:diagram}}
\end{figure}
In unserer Implementierung gilt f√ºr Verteilung $[1]$ $n_{max} = 29$ und f√ºr Verteilung $[2]$ $n_{max} = 27$.\\
\begin{adjustwidth}{-1cm}{}
\begin{tabular}{l|rrrrrrrrrrrrrrrrrrrr}
	$n$ & 10 & 11 & 12 & 13 & 14 & 15 & 16 & 17 & 18 & 19 & 20 & 21 & 22 & 23 & 24 & 25 & 26 & 27 & 28 & 29\\
	\midrule
	$m_3^{[1]}(n)$ & 61 & 62 & 66 & 72 & 76 & 80 & 85 & 88 & 91 & 98 & 99 & 104 & 108 & 111 & 116 & 122 & 125 & 130 & 133 & 135\\
	\midrule
	$m_3^{[2]}(n)$ & 51 & 54 & 59 & 63 & 67 & 71 & 74 & 81 & 84 & 88 & 91 & 97 & 102 & 105 & 107 & 113 & 117 & 123 & & \\
\end{tabular}
\end{adjustwidth}
\vspace{10pt}
Wie man sieht, gilt durchg√§ngig $m_3^{[1]}(n) > m_3^{[2]}(n)$. Dies haben wir erwartet, da Verteilung $[1]$ auch Klauseln erstellen kann, in denen $x \vee \non{x}$ vorkommt f√ºr eine Variable $x$. Dadurch sind Formeln nach Verteilung $[1]$ tendenziell eher erf√ºllbar. Diese Ergebnisse sind ebenfalls zu sehen in Abbildung \ref{fig:diagram}.

Es ist hierbei ein nahezu linearer Anstieg von $m_3^{[i]}(n)$ erkennbar. Mittels linearer Regression kann die Line of Best Fit bestimmt werden. Diese betr√§gt:\\
$m_3^{[1]}(n) \approx 18.72+4.07\cdot n$\\
$m_3^{[2]}(n) \approx 8.37+4.19\cdot n$\\
Auf den ersten Blick scheint die Vermutung aus der Aufgabenstellung somit erf√ºllt zu sein, aber diese impliziert, dass die Line of Best Fit nahe an $(0,0)$ verlaufen m√ºsste, was nicht der Fall ist. Ferner w√ºrde hierdurch ab einem $N$ die Ungleichung $m_3^{[1]}(N) < m_3^{[2]}(N)$ gelten, was keinen Sinn ergibt.\par
Falls $m_3^{[1]}(0) = m_3^{[2]}(0) = 0$ verlangt wird, so f√ºhrt dies zu folgenden Ergebnissen:\\
$m_3^{[1]}(n) \approx 4.94\cdot n$\\
$m_3^{[2]}(n) \approx 4.61\cdot n$\\
Diese f√ºhrt aber f√ºr Verteilung $[1]$ selbst bei gro√üen $n$ zu sehr starken Abweichungen. F√ºr Verteilung $[2]$ hingegen liegen die Ergebnisse \emph{insbesondere} f√ºr gro√üe $n$ recht nahe an dieser Linie.\par
Somit ist $\tau_3 = 4.61$ ein plausibler Wert f√ºr Verteilung $[2]$. F√ºr Verteilung $[1]$ ist der beste Wert $\tau_3 = 4.94$, dieser ist aber auf diesen Ergebnissen nicht besonders gut.

\subsection{3.3b)}
\begin{figure}[t]
	\includegraphics[width=\linewidth]{Diagram-A.png}
	\caption{Variante 1 n_max = 29; M=[122,148]}
\end{figure}

\begin{figure}[t]
	\includegraphics[width=\linewidth]{Diagram-B.png}
	\caption{Variante 1 n_max = 27; M=[111,135]}
\end{figure}
\end{document}